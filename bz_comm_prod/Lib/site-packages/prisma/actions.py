# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class CommendationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Commendation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Commendation.prisma().query_raw(
            'SELECT * FROM Commendation WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Commendation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Commendation.prisma().query_first(
            'SELECT * FROM Commendation WHERE message = $1',
            'dhheabfhf',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CommendationCreateInput,
        include: Optional[types.CommendationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Commendation record.

        Parameters
        ----------
        data
            Commendation record data
        include
            Specifies which relations should be loaded on the returned Commendation model

        Returns
        -------
        prisma.models.Commendation
            The created Commendation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Commendation record from just the required fields
        commendation = Commendation.prisma().create(
            data={
                # data to create a Commendation record
                'message': 'ggciceaie',
                'recipientId': 'bbehjachib',
                'senderId': 'cadfabfehe',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.CommendationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Commendation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Commendation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Commendation.prisma().create_many(
            data=[
                {
                    # data to create a Commendation record
                    'message': 'dgiiaaijj',
                    'recipientId': 'bfaiacjjfc',
                    'senderId': 'eigcfgbif',
                },
                {
                    # data to create a Commendation record
                    'message': 'bagcfbhiig',
                    'recipientId': 'cghideieh',
                    'senderId': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CommendationWhereUniqueInput,
        include: Optional[types.CommendationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Commendation record.

        Parameters
        ----------
        where
            Commendation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Commendation model

        Returns
        -------
        prisma.models.Commendation
            The deleted Commendation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commendation = Commendation.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.CommendationWhereUniqueInput,
        include: Optional[types.CommendationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Commendation record.

        Parameters
        ----------
        where
            Commendation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Commendation model

        Returns
        -------
        prisma.models.Commendation
            The found Commendation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commendation = Commendation.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_unique_or_raise(
        self,
        where: types.CommendationWhereUniqueInput,
        include: Optional[types.CommendationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Commendation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Commendation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Commendation model

        Returns
        -------
        prisma.models.Commendation
            The found Commendation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commendation = Commendation.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommendationWhereInput] = None,
        cursor: Optional[types.CommendationWhereUniqueInput] = None,
        include: Optional[types.CommendationInclude] = None,
        order: Optional[Union[types.CommendationOrderByInput, List[types.CommendationOrderByInput]]] = None,
        distinct: Optional[List[types.CommendationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Commendation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Commendation records returned
        skip
            Ignore the first N results
        where
            Commendation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Commendation model
        order
            Order the returned Commendation records by any field
        distinct
            Filter Commendation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Commendation]
            The list of all Commendation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Commendation records
        commendations = Commendation.prisma().find_many(take=10)

        # find the first 5 Commendation records ordered by the recipientId field
        commendations = Commendation.prisma().find_many(
            take=5,
            order={
                'recipientId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommendationWhereInput] = None,
        cursor: Optional[types.CommendationWhereUniqueInput] = None,
        include: Optional[types.CommendationInclude] = None,
        order: Optional[Union[types.CommendationOrderByInput, List[types.CommendationOrderByInput]]] = None,
        distinct: Optional[List[types.CommendationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Commendation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Commendation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Commendation model
        order
            Order the returned Commendation records by any field
        distinct
            Filter Commendation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Commendation
            The first Commendation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Commendation record ordered by the senderId field
        commendation = Commendation.prisma().find_first(
            skip=1,
            order={
                'senderId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommendationWhereInput] = None,
        cursor: Optional[types.CommendationWhereUniqueInput] = None,
        include: Optional[types.CommendationInclude] = None,
        order: Optional[Union[types.CommendationOrderByInput, List[types.CommendationOrderByInput]]] = None,
        distinct: Optional[List[types.CommendationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Commendation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Commendation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Commendation model
        order
            Order the returned Commendation records by any field
        distinct
            Filter Commendation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Commendation
            The first Commendation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Commendation record ordered by the createdAt field
        commendation = Commendation.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update(
        self,
        data: types.CommendationUpdateInput,
        where: types.CommendationWhereUniqueInput,
        include: Optional[types.CommendationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Commendation record.

        Parameters
        ----------
        data
            Commendation record data specifying what to update
        where
            Commendation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Commendation model

        Returns
        -------
        prisma.models.Commendation
            The updated Commendation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        commendation = Commendation.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the Commendation record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.CommendationWhereUniqueInput,
        data: types.CommendationUpsertInput,
        include: Optional[types.CommendationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Commendation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Commendation model

        Returns
        -------
        prisma.models.Commendation
            The created or updated Commendation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commendation = Commendation.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'message': 'bagcfbhiig',
                    'recipientId': 'cghideieh',
                    'senderId': 'biabhbdai',
                },
                'update': {
                    'message': 'bagcfbhiig',
                    'recipientId': 'cghideieh',
                    'senderId': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.CommendationUpdateManyMutationInput,
        where: types.CommendationWhereInput,
    ) -> int:
        """Update multiple Commendation records

        Parameters
        ----------
        data
            Commendation data to update the selected Commendation records to
        where
            Filter to select the Commendation records to update

        Returns
        -------
        int
            The total number of Commendation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Commendation records
        total = Commendation.prisma().update_many(
            data={
                'id': 'bgeecijdgg'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommendationWhereInput] = None,
        cursor: Optional[types.CommendationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Commendation records present in the database

        Parameters
        ----------
        select
            Select the Commendation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Commendation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommendationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Commendation.prisma().count()

        # results: prisma.types.CommendationCountAggregateOutput
        results = Commendation.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CommendationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommendationWhereInput] = None,
        cursor: Optional[types.CommendationWhereUniqueInput] = None,
    ) -> types.CommendationCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CommendationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommendationWhereInput] = None,
        cursor: Optional[types.CommendationWhereUniqueInput] = None,
    ) -> Union[int, types.CommendationCountAggregateOutput]:
        """Count the number of Commendation records present in the database

        Parameters
        ----------
        select
            Select the Commendation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Commendation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommendationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Commendation.prisma().count()

        # results: prisma.types.CommendationCountAggregateOutput
        results = Commendation.prisma().count(
            select={
                '_all': True,
                'recipientId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommendationCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CommendationWhereInput] = None
    ) -> int:
        """Delete multiple Commendation records.

        Parameters
        ----------
        where
            Optional Commendation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Commendation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Commendation records
        total = Commendation.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CommendationScalarFieldKeys'],
        *,
        where: Optional['types.CommendationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommendationAvgAggregateInput'] = None,
        sum: Optional['types.CommendationSumAggregateInput'] = None,
        min: Optional['types.CommendationMinAggregateInput'] = None,
        max: Optional['types.CommendationMaxAggregateInput'] = None,
        having: Optional['types.CommendationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommendationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommendationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommendationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommendationGroupByOutput']:
        """Group Commendation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Commendation fields to group records by
        where
            Commendation filter to select records
        take
            Limit the maximum number of Commendation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommendationGroupByOutput]
            A list of dictionaries representing the Commendation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Commendation records by senderId values
        # and count how many records are in each group
        results = Commendation.prisma().group_by(
            ['senderId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Member]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Member.prisma().query_raw(
            'SELECT * FROM Member WHERE id = $1',
            'bdiicjafbj',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Member
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Member.prisma().query_first(
            'SELECT * FROM Member WHERE name = $1',
            'bgehebiafc',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.MemberCreateInput,
        include: Optional[types.MemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new Member record.

        Parameters
        ----------
        data
            Member record data
        include
            Specifies which relations should be loaded on the returned Member model

        Returns
        -------
        prisma.models.Member
            The created Member record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Member record from just the required fields
        member = Member.prisma().create(
            data={
                # data to create a Member record
                'name': 'bghffegacj',
                'email': 'bhghchehcc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.MemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Member records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Member record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Member.prisma().create_many(
            data=[
                {
                    # data to create a Member record
                    'name': 'dcgchcbbf',
                    'email': 'bdedcabahc',
                },
                {
                    # data to create a Member record
                    'name': 'ghfhiafcb',
                    'email': 'heejgedji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.MemberWhereUniqueInput,
        include: Optional[types.MemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Member record.

        Parameters
        ----------
        where
            Member filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Member model

        Returns
        -------
        prisma.models.Member
            The deleted Member record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        member = Member.prisma().delete(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.MemberWhereUniqueInput,
        include: Optional[types.MemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Member record.

        Parameters
        ----------
        where
            Member filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Member model

        Returns
        -------
        prisma.models.Member
            The found Member record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        member = Member.prisma().find_unique(
            where={
                'id': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_unique_or_raise(
        self,
        where: types.MemberWhereUniqueInput,
        include: Optional[types.MemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Member record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Member filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Member model

        Returns
        -------
        prisma.models.Member
            The found Member record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        member = Member.prisma().find_unique_or_raise(
            where={
                'id': 'igbehcbab',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemberWhereInput] = None,
        cursor: Optional[types.MemberWhereUniqueInput] = None,
        include: Optional[types.MemberInclude] = None,
        order: Optional[Union[types.MemberOrderByInput, List[types.MemberOrderByInput]]] = None,
        distinct: Optional[List[types.MemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Member records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Member records returned
        skip
            Ignore the first N results
        where
            Member filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Member model
        order
            Order the returned Member records by any field
        distinct
            Filter Member records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Member]
            The list of all Member records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Member records
        members = Member.prisma().find_many(take=10)

        # find the first 5 Member records ordered by the email field
        members = Member.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MemberWhereInput] = None,
        cursor: Optional[types.MemberWhereUniqueInput] = None,
        include: Optional[types.MemberInclude] = None,
        order: Optional[Union[types.MemberOrderByInput, List[types.MemberOrderByInput]]] = None,
        distinct: Optional[List[types.MemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Member record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Member filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Member model
        order
            Order the returned Member records by any field
        distinct
            Filter Member records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Member
            The first Member record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Member record ordered by the phone field
        member = Member.prisma().find_first(
            skip=1,
            order={
                'phone': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MemberWhereInput] = None,
        cursor: Optional[types.MemberWhereUniqueInput] = None,
        include: Optional[types.MemberInclude] = None,
        order: Optional[Union[types.MemberOrderByInput, List[types.MemberOrderByInput]]] = None,
        distinct: Optional[List[types.MemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Member record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Member filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Member model
        order
            Order the returned Member records by any field
        distinct
            Filter Member records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Member
            The first Member record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Member record ordered by the imageURL field
        member = Member.prisma().find_first_or_raise(
            skip=1,
            order={
                'imageURL': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update(
        self,
        data: types.MemberUpdateInput,
        where: types.MemberWhereUniqueInput,
        include: Optional[types.MemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Member record.

        Parameters
        ----------
        data
            Member record data specifying what to update
        where
            Member filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Member model

        Returns
        -------
        prisma.models.Member
            The updated Member record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        member = Member.prisma().update(
            where={
                'id': 'bdadaadhag',
            },
            data={
                # data to update the Member record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.MemberWhereUniqueInput,
        data: types.MemberUpsertInput,
        include: Optional[types.MemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Member filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Member model

        Returns
        -------
        prisma.models.Member
            The created or updated Member record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        member = Member.prisma().upsert(
            where={
                'id': 'bgiggdidbf',
            },
            data={
                'create': {
                    'id': 'bgiggdidbf',
                    'name': 'ghfhiafcb',
                    'email': 'heejgedji',
                },
                'update': {
                    'name': 'ghfhiafcb',
                    'email': 'heejgedji',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.MemberUpdateManyMutationInput,
        where: types.MemberWhereInput,
    ) -> int:
        """Update multiple Member records

        Parameters
        ----------
        data
            Member data to update the selected Member records to
        where
            Filter to select the Member records to update

        Returns
        -------
        int
            The total number of Member records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Member records
        total = Member.prisma().update_many(
            data={
                'id': 'caaaedabfc'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemberWhereInput] = None,
        cursor: Optional[types.MemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Member records present in the database

        Parameters
        ----------
        select
            Select the Member fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Member filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Member.prisma().count()

        # results: prisma.types.MemberCountAggregateOutput
        results = Member.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.MemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemberWhereInput] = None,
        cursor: Optional[types.MemberWhereUniqueInput] = None,
    ) -> types.MemberCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.MemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MemberWhereInput] = None,
        cursor: Optional[types.MemberWhereUniqueInput] = None,
    ) -> Union[int, types.MemberCountAggregateOutput]:
        """Count the number of Member records present in the database

        Parameters
        ----------
        select
            Select the Member fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Member filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Member.prisma().count()

        # results: prisma.types.MemberCountAggregateOutput
        results = Member.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MemberCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.MemberWhereInput] = None
    ) -> int:
        """Delete multiple Member records.

        Parameters
        ----------
        where
            Optional Member filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Member records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Member records
        total = Member.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.MemberScalarFieldKeys'],
        *,
        where: Optional['types.MemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MemberAvgAggregateInput'] = None,
        sum: Optional['types.MemberSumAggregateInput'] = None,
        min: Optional['types.MemberMinAggregateInput'] = None,
        max: Optional['types.MemberMaxAggregateInput'] = None,
        having: Optional['types.MemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MemberGroupByOutput']:
        """Group Member records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Member fields to group records by
        where
            Member filter to select records
        take
            Limit the maximum number of Member records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MemberGroupByOutput]
            A list of dictionaries representing the Member record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Member records by phone values
        # and count how many records are in each group
        results = Member.prisma().group_by(
            ['phone'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Team]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Team.prisma().query_raw(
            'SELECT * FROM Team WHERE id = $1',
            'bigibebcib',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Team
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Team.prisma().query_first(
            'SELECT * FROM Team WHERE name = $1',
            'bigaiehgcc',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TeamCreateInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Create a new Team record.

        Parameters
        ----------
        data
            Team record data
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created Team record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Team record from just the required fields
        team = Team.prisma().create(
            data={
                # data to create a Team record
                'name': 'beeifcbebf',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.TeamCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Team records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Team record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Team.prisma().create_many(
            data=[
                {
                    # data to create a Team record
                    'name': 'bgcigfahea',
                },
                {
                    # data to create a Team record
                    'name': 'bcejgaggif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Team record.

        Parameters
        ----------
        where
            Team filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The deleted Team record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Team record.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_unique_or_raise(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Team record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Team records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N results
        where
            Team filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Team]
            The list of all Team records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Team records
        teams = Team.prisma().find_many(take=10)

        # find the first 5 Team records ordered by the imageURL field
        teams = Team.prisma().find_many(
            take=5,
            order={
                'imageURL': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Team record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the id field
        team = Team.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Team record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the name field
        team = Team.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update(
        self,
        data: types.TeamUpdateInput,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Team record.

        Parameters
        ----------
        data
            Team record data specifying what to update
        where
            Team filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The updated Team record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        team = Team.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the Team record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.TeamWhereUniqueInput,
        data: types.TeamUpsertInput,
        include: Optional[types.TeamInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Team filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created or updated Team record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'name': 'bcejgaggif',
                },
                'update': {
                    'name': 'bcejgaggif',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.TeamUpdateManyMutationInput,
        where: types.TeamWhereInput,
    ) -> int:
        """Update multiple Team records

        Parameters
        ----------
        data
            Team data to update the selected Team records to
        where
            Filter to select the Team records to update

        Returns
        -------
        int
            The total number of Team records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Team records
        total = Team.prisma().update_many(
            data={
                'imageURL': 'jjfeafhfj'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = Team.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TeamCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> types.TeamCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TeamCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> Union[int, types.TeamCountAggregateOutput]:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = Team.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TeamWhereInput] = None
    ) -> int:
        """Delete multiple Team records.

        Parameters
        ----------
        where
            Optional Team filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Team records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Team records
        total = Team.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TeamScalarFieldKeys'],
        *,
        where: Optional['types.TeamWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamAvgAggregateInput'] = None,
        sum: Optional['types.TeamSumAggregateInput'] = None,
        min: Optional['types.TeamMinAggregateInput'] = None,
        max: Optional['types.TeamMaxAggregateInput'] = None,
        having: Optional['types.TeamScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TeamScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamGroupByOutput']:
        """Group Team records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Team fields to group records by
        where
            Team filter to select records
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamGroupByOutput]
            A list of dictionaries representing the Team record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Team records by imageURL values
        # and count how many records are in each group
        results = Team.prisma().group_by(
            ['imageURL'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RoleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Role]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Role.prisma().query_raw(
            'SELECT * FROM Role WHERE id = $1',
            'cbachdgfce',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Role
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Role.prisma().query_first(
            'SELECT * FROM Role WHERE name = $1',
            'chbfcacbd',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.RoleCreateInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Role record.

        Parameters
        ----------
        data
            Role record data
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created Role record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Role record from just the required fields
        role = Role.prisma().create(
            data={
                # data to create a Role record
                'name': 'efggddide',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.RoleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Role records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Role record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Role.prisma().create_many(
            data=[
                {
                    # data to create a Role record
                    'name': 'caficfigfb',
                },
                {
                    # data to create a Role record
                    'name': 'bfidgijfjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Role record.

        Parameters
        ----------
        where
            Role filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The deleted Role record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().delete(
            where={
                'id': 'ihieecagf',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Role record.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().find_unique(
            where={
                'id': 'bghfciaafe',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_unique_or_raise(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Role record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().find_unique_or_raise(
            where={
                'id': 'bgchfhgceh',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Role records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N results
        where
            Role filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Role]
            The list of all Role records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Role records
        roles = Role.prisma().find_many(take=10)

        # find the first 5 Role records ordered by the id field
        roles = Role.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Role record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the name field
        role = Role.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Role record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the id field
        role = Role.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update(
        self,
        data: types.RoleUpdateInput,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Role record.

        Parameters
        ----------
        data
            Role record data specifying what to update
        where
            Role filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The updated Role record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        role = Role.prisma().update(
            where={
                'id': 'cafeiaccbc',
            },
            data={
                # data to update the Role record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.RoleWhereUniqueInput,
        data: types.RoleUpsertInput,
        include: Optional[types.RoleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Role filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created or updated Role record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = Role.prisma().upsert(
            where={
                'id': 'gaddfhfh',
            },
            data={
                'create': {
                    'id': 'gaddfhfh',
                    'name': 'bfidgijfjc',
                },
                'update': {
                    'name': 'bfidgijfjc',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.RoleUpdateManyMutationInput,
        where: types.RoleWhereInput,
    ) -> int:
        """Update multiple Role records

        Parameters
        ----------
        data
            Role data to update the selected Role records to
        where
            Filter to select the Role records to update

        Returns
        -------
        int
            The total number of Role records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Role records
        total = Role.prisma().update_many(
            data={
                'name': 'gieegcbeg'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = Role.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.RoleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> types.RoleCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.RoleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> Union[int, types.RoleCountAggregateOutput]:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = Role.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RoleCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.RoleWhereInput] = None
    ) -> int:
        """Delete multiple Role records.

        Parameters
        ----------
        where
            Optional Role filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Role records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Role records
        total = Role.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.RoleScalarFieldKeys'],
        *,
        where: Optional['types.RoleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RoleAvgAggregateInput'] = None,
        sum: Optional['types.RoleSumAggregateInput'] = None,
        min: Optional['types.RoleMinAggregateInput'] = None,
        max: Optional['types.RoleMaxAggregateInput'] = None,
        having: Optional['types.RoleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RoleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RoleGroupByOutput']:
        """Group Role records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Role fields to group records by
        where
            Role filter to select records
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RoleGroupByOutput]
            A list of dictionaries representing the Role record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Role records by id values
        # and count how many records are in each group
        results = Role.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamLeadersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamLeaders]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = TeamLeaders.prisma().query_raw(
            'SELECT * FROM TeamLeaders WHERE id = $1',
            'bgcffadich',
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamLeaders
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = TeamLeaders.prisma().query_first(
            'SELECT * FROM TeamLeaders WHERE memberId = $1',
            'fcbichhci',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TeamLeadersCreateInput,
        include: Optional[types.TeamLeadersInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamLeaders record.

        Parameters
        ----------
        data
            TeamLeaders record data
        include
            Specifies which relations should be loaded on the returned TeamLeaders model

        Returns
        -------
        prisma.models.TeamLeaders
            The created TeamLeaders record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamLeaders record from just the required fields
        teamleaders = TeamLeaders.prisma().create(
            data={
                # data to create a TeamLeaders record
                'memberId': 'bcggadccgf',
                'teamId': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def create_many(
        self,
        data: List[types.TeamLeadersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamLeaders records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamLeaders record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = TeamLeaders.prisma().create_many(
            data=[
                {
                    # data to create a TeamLeaders record
                    'memberId': 'cafdaehjid',
                    'teamId': 'gifdddbia',
                },
                {
                    # data to create a TeamLeaders record
                    'memberId': 'bchehecef',
                    'teamId': 'jeijcbhfe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TeamLeadersWhereUniqueInput,
        include: Optional[types.TeamLeadersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamLeaders record.

        Parameters
        ----------
        where
            TeamLeaders filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamLeaders model

        Returns
        -------
        prisma.models.TeamLeaders
            The deleted TeamLeaders record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamleaders = TeamLeaders.prisma().delete(
            where={
                'id': 'bjgejjabff',
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def find_unique(
        self,
        where: types.TeamLeadersWhereUniqueInput,
        include: Optional[types.TeamLeadersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamLeaders record.

        Parameters
        ----------
        where
            TeamLeaders filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamLeaders model

        Returns
        -------
        prisma.models.TeamLeaders
            The found TeamLeaders record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamleaders = TeamLeaders.prisma().find_unique(
            where={
                'id': 'bcciijbibg',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_unique_or_raise(
        self,
        where: types.TeamLeadersWhereUniqueInput,
        include: Optional[types.TeamLeadersInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamLeaders record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamLeaders filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamLeaders model

        Returns
        -------
        prisma.models.TeamLeaders
            The found TeamLeaders record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamleaders = TeamLeaders.prisma().find_unique_or_raise(
            where={
                'id': 'cffcachfd',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamLeadersWhereInput] = None,
        cursor: Optional[types.TeamLeadersWhereUniqueInput] = None,
        include: Optional[types.TeamLeadersInclude] = None,
        order: Optional[Union[types.TeamLeadersOrderByInput, List[types.TeamLeadersOrderByInput]]] = None,
        distinct: Optional[List[types.TeamLeadersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamLeaders records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamLeaders records returned
        skip
            Ignore the first N results
        where
            TeamLeaders filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamLeaders model
        order
            Order the returned TeamLeaders records by any field
        distinct
            Filter TeamLeaders records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamLeaders]
            The list of all TeamLeaders records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamLeaders records
        teamleaders = TeamLeaders.prisma().find_many(take=10)

        # find the first 5 TeamLeaders records ordered by the teamId field
        teamleaders = TeamLeaders.prisma().find_many(
            take=5,
            order={
                'teamId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamLeadersWhereInput] = None,
        cursor: Optional[types.TeamLeadersWhereUniqueInput] = None,
        include: Optional[types.TeamLeadersInclude] = None,
        order: Optional[Union[types.TeamLeadersOrderByInput, List[types.TeamLeadersOrderByInput]]] = None,
        distinct: Optional[List[types.TeamLeadersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamLeaders record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamLeaders filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamLeaders model
        order
            Order the returned TeamLeaders records by any field
        distinct
            Filter TeamLeaders records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamLeaders
            The first TeamLeaders record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamLeaders record ordered by the id field
        teamleaders = TeamLeaders.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamLeadersWhereInput] = None,
        cursor: Optional[types.TeamLeadersWhereUniqueInput] = None,
        include: Optional[types.TeamLeadersInclude] = None,
        order: Optional[Union[types.TeamLeadersOrderByInput, List[types.TeamLeadersOrderByInput]]] = None,
        distinct: Optional[List[types.TeamLeadersScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamLeaders record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamLeaders filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamLeaders model
        order
            Order the returned TeamLeaders records by any field
        distinct
            Filter TeamLeaders records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamLeaders
            The first TeamLeaders record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamLeaders record ordered by the memberId field
        teamleaders = TeamLeaders.prisma().find_first_or_raise(
            skip=1,
            order={
                'memberId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update(
        self,
        data: types.TeamLeadersUpdateInput,
        where: types.TeamLeadersWhereUniqueInput,
        include: Optional[types.TeamLeadersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamLeaders record.

        Parameters
        ----------
        data
            TeamLeaders record data specifying what to update
        where
            TeamLeaders filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamLeaders model

        Returns
        -------
        prisma.models.TeamLeaders
            The updated TeamLeaders record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teamleaders = TeamLeaders.prisma().update(
            where={
                'id': 'bccdfhdigc',
            },
            data={
                # data to update the TeamLeaders record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    def upsert(
        self,
        where: types.TeamLeadersWhereUniqueInput,
        data: types.TeamLeadersUpsertInput,
        include: Optional[types.TeamLeadersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamLeaders filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamLeaders model

        Returns
        -------
        prisma.models.TeamLeaders
            The created or updated TeamLeaders record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamleaders = TeamLeaders.prisma().upsert(
            where={
                'id': 'febcgjbfj',
            },
            data={
                'create': {
                    'id': 'febcgjbfj',
                    'memberId': 'bchehecef',
                    'teamId': 'jeijcbhfe',
                },
                'update': {
                    'memberId': 'bchehecef',
                    'teamId': 'jeijcbhfe',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    def update_many(
        self,
        data: types.TeamLeadersUpdateManyMutationInput,
        where: types.TeamLeadersWhereInput,
    ) -> int:
        """Update multiple TeamLeaders records

        Parameters
        ----------
        data
            TeamLeaders data to update the selected TeamLeaders records to
        where
            Filter to select the TeamLeaders records to update

        Returns
        -------
        int
            The total number of TeamLeaders records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamLeaders records
        total = TeamLeaders.prisma().update_many(
            data={
                'teamId': 'bageiegghg'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamLeadersWhereInput] = None,
        cursor: Optional[types.TeamLeadersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamLeaders records present in the database

        Parameters
        ----------
        select
            Select the TeamLeaders fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamLeaders filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamLeadersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = TeamLeaders.prisma().count()

        # results: prisma.types.TeamLeadersCountAggregateOutput
        results = TeamLeaders.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TeamLeadersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamLeadersWhereInput] = None,
        cursor: Optional[types.TeamLeadersWhereUniqueInput] = None,
    ) -> types.TeamLeadersCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TeamLeadersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamLeadersWhereInput] = None,
        cursor: Optional[types.TeamLeadersWhereUniqueInput] = None,
    ) -> Union[int, types.TeamLeadersCountAggregateOutput]:
        """Count the number of TeamLeaders records present in the database

        Parameters
        ----------
        select
            Select the TeamLeaders fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamLeaders filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamLeadersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = TeamLeaders.prisma().count()

        # results: prisma.types.TeamLeadersCountAggregateOutput
        results = TeamLeaders.prisma().count(
            select={
                '_all': True,
                'memberId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamLeadersCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TeamLeadersWhereInput] = None
    ) -> int:
        """Delete multiple TeamLeaders records.

        Parameters
        ----------
        where
            Optional TeamLeaders filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamLeaders records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamLeaders records
        total = TeamLeaders.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TeamLeadersScalarFieldKeys'],
        *,
        where: Optional['types.TeamLeadersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamLeadersAvgAggregateInput'] = None,
        sum: Optional['types.TeamLeadersSumAggregateInput'] = None,
        min: Optional['types.TeamLeadersMinAggregateInput'] = None,
        max: Optional['types.TeamLeadersMaxAggregateInput'] = None,
        having: Optional['types.TeamLeadersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamLeadersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamLeadersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TeamLeadersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamLeadersGroupByOutput']:
        """Group TeamLeaders records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamLeaders fields to group records by
        where
            TeamLeaders filter to select records
        take
            Limit the maximum number of TeamLeaders records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamLeadersGroupByOutput]
            A list of dictionaries representing the TeamLeaders record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamLeaders records by teamId values
        # and count how many records are in each group
        results = TeamLeaders.prisma().group_by(
            ['teamId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models