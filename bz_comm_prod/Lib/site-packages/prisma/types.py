# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = Literal['default', 'insensitive']
SortOrder = Literal['asc', 'desc']


class _DatasourceOverrideOptional(TypedDict, total=False):
    env: str
    name: str


class DatasourceOverride(_DatasourceOverrideOptional):
    url: str


# NOTE: we don't support some options as their type hints are not publicly exposed
# https://github.com/encode/httpx/discussions/1977
class HttpConfig(TypedDict, total=False):
    app: Callable[[Mapping[str, Any], Any], Any]
    http1: bool
    http2: bool
    limits: httpx.Limits
    timeout: Union[None, float, httpx.Timeout]
    trust_env: bool
    max_redirects: int


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Commendation types

class CommendationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Commendation create method"""
    id: _str
    recipientId: _str
    senderId: _str
    createdAt: datetime.datetime
    recipient: 'MemberCreateNestedWithoutRelationsInput'
    sender: 'MemberCreateNestedWithoutRelationsInput'


class CommendationCreateInput(CommendationOptionalCreateInput):
    """Required arguments to the Commendation create method"""
    message: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CommendationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Commendation create method, without relations"""
    id: _str
    recipientId: _str
    senderId: _str
    createdAt: datetime.datetime


class CommendationCreateWithoutRelationsInput(CommendationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Commendation create method, without relations"""
    message: _str


class CommendationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CommendationCreateWithoutRelationsInput'
    connect: 'CommendationWhereUniqueInput'


class CommendationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CommendationCreateWithoutRelationsInput', List['CommendationCreateWithoutRelationsInput']]
    connect: Union['CommendationWhereUniqueInput', List['CommendationWhereUniqueInput']]


_CommendationWhereUnique_id_Input = TypedDict(
    '_CommendationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CommendationWhereUniqueInput = _CommendationWhereUnique_id_Input


class CommendationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    message: _str
    createdAt: datetime.datetime
    recipient: 'MemberUpdateOneWithoutRelationsInput'
    sender: 'MemberUpdateOneWithoutRelationsInput'


class CommendationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    message: _str
    createdAt: datetime.datetime


class CommendationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CommendationCreateWithoutRelationsInput']
    connect: List['CommendationWhereUniqueInput']
    set: List['CommendationWhereUniqueInput']
    disconnect: List['CommendationWhereUniqueInput']
    delete: List['CommendationWhereUniqueInput']

    # TODO
    # update: List['CommendationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CommendationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CommendationScalarWhereInput']
    # upsert: List['CommendationUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['CommendationCreateOrConnectWithoutRelationsInput']


class CommendationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CommendationCreateWithoutRelationsInput'
    connect: 'CommendationWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CommendationUpdateInput'
    # upsert: 'CommendationUpsertWithoutRelationsInput'
    # connectOrCreate: 'CommendationCreateOrConnectWithoutRelationsInput'


class CommendationUpsertInput(TypedDict):
    create: 'CommendationCreateInput'
    update: 'CommendationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Commendation_id_OrderByInput = TypedDict(
    '_Commendation_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Commendation_message_OrderByInput = TypedDict(
    '_Commendation_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_Commendation_recipientId_OrderByInput = TypedDict(
    '_Commendation_recipientId_OrderByInput',
    {
        'recipientId': 'SortOrder',
    },
    total=True
)

_Commendation_senderId_OrderByInput = TypedDict(
    '_Commendation_senderId_OrderByInput',
    {
        'senderId': 'SortOrder',
    },
    total=True
)

_Commendation_createdAt_OrderByInput = TypedDict(
    '_Commendation_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

CommendationOrderByInput = Union[
    '_Commendation_id_OrderByInput',
    '_Commendation_message_OrderByInput',
    '_Commendation_recipientId_OrderByInput',
    '_Commendation_senderId_OrderByInput',
    '_Commendation_createdAt_OrderByInput',
]



# recursive Commendation types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CommendationRelationFilter = TypedDict(
    'CommendationRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CommendationListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CommendationInclude(TypedDict, total=False):
    """Commendation relational arguments"""
    recipient: Union[bool, 'MemberArgsFromCommendation']
    sender: Union[bool, 'MemberArgsFromCommendation']


    

class CommendationIncludeFromCommendation(TypedDict, total=False):
    """Relational arguments for Commendation"""
    recipient: Union[bool, 'MemberArgsFromCommendationRecursive1']
    sender: Union[bool, 'MemberArgsFromCommendationRecursive1']


class CommendationIncludeFromCommendationRecursive1(TypedDict, total=False):
    """Relational arguments for Commendation"""
    recipient: Union[bool, 'MemberArgsFromCommendationRecursive2']
    sender: Union[bool, 'MemberArgsFromCommendationRecursive2']


class CommendationIncludeFromCommendationRecursive2(TypedDict, total=False):
    """Relational arguments for Commendation"""
    recipient: Union[bool, 'MemberArgsFromCommendationRecursive3']
    sender: Union[bool, 'MemberArgsFromCommendationRecursive3']


class CommendationIncludeFromCommendationRecursive3(TypedDict, total=False):
    """Relational arguments for Commendation"""
    recipient: Union[bool, 'MemberArgsFromCommendationRecursive4']
    sender: Union[bool, 'MemberArgsFromCommendationRecursive4']


class CommendationIncludeFromCommendationRecursive4(TypedDict, total=False):
    """Relational arguments for Commendation"""

    

class CommendationArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'CommendationIncludeFromCommendationRecursive1'


class CommendationArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'CommendationIncludeFromCommendationRecursive2'


class CommendationArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'CommendationIncludeFromCommendationRecursive3'


class CommendationArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'CommendationIncludeFromCommendationRecursive4'


class CommendationArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    
    

class FindManyCommendationArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive1'


class FindManyCommendationArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive2'


class FindManyCommendationArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive3'


class FindManyCommendationArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive4'


class FindManyCommendationArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    
    

class MemberIncludeFromCommendation(TypedDict, total=False):
    """Relational arguments for Commendation"""
    commendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive1']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive1']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive1']
    roles: Union[bool, 'FindManyRoleArgsFromCommendationRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromCommendationRecursive1']


class MemberIncludeFromCommendationRecursive1(TypedDict, total=False):
    """Relational arguments for Commendation"""
    commendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive2']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive2']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive2']
    roles: Union[bool, 'FindManyRoleArgsFromCommendationRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromCommendationRecursive2']


class MemberIncludeFromCommendationRecursive2(TypedDict, total=False):
    """Relational arguments for Commendation"""
    commendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive3']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive3']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive3']
    roles: Union[bool, 'FindManyRoleArgsFromCommendationRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromCommendationRecursive3']


class MemberIncludeFromCommendationRecursive3(TypedDict, total=False):
    """Relational arguments for Commendation"""
    commendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive4']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromCommendationRecursive4']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive4']
    roles: Union[bool, 'FindManyRoleArgsFromCommendationRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromCommendationRecursive4']


class MemberIncludeFromCommendationRecursive4(TypedDict, total=False):
    """Relational arguments for Commendation"""

    

class MemberArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'MemberIncludeFromMemberRecursive1'


class MemberArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'MemberIncludeFromMemberRecursive2'


class MemberArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'MemberIncludeFromMemberRecursive3'


class MemberArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'MemberIncludeFromMemberRecursive4'


class MemberArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    
    

class FindManyMemberArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive1'


class FindManyMemberArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive2'


class FindManyMemberArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive3'


class FindManyMemberArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive4'


class FindManyMemberArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    
    

class TeamIncludeFromCommendation(TypedDict, total=False):
    """Relational arguments for Commendation"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive1']
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive1']


class TeamIncludeFromCommendationRecursive1(TypedDict, total=False):
    """Relational arguments for Commendation"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive2']
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive2']


class TeamIncludeFromCommendationRecursive2(TypedDict, total=False):
    """Relational arguments for Commendation"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive3']
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive3']


class TeamIncludeFromCommendationRecursive3(TypedDict, total=False):
    """Relational arguments for Commendation"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromCommendationRecursive4']
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive4']


class TeamIncludeFromCommendationRecursive4(TypedDict, total=False):
    """Relational arguments for Commendation"""

    

class TeamArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    
    

class FindManyTeamArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class RoleIncludeFromCommendation(TypedDict, total=False):
    """Relational arguments for Commendation"""
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive1']


class RoleIncludeFromCommendationRecursive1(TypedDict, total=False):
    """Relational arguments for Commendation"""
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive2']


class RoleIncludeFromCommendationRecursive2(TypedDict, total=False):
    """Relational arguments for Commendation"""
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive3']


class RoleIncludeFromCommendationRecursive3(TypedDict, total=False):
    """Relational arguments for Commendation"""
    members: Union[bool, 'FindManyMemberArgsFromCommendationRecursive4']


class RoleIncludeFromCommendationRecursive4(TypedDict, total=False):
    """Relational arguments for Commendation"""

    

class RoleArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'RoleIncludeFromRoleRecursive1'


class RoleArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'RoleIncludeFromRoleRecursive2'


class RoleArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'RoleIncludeFromRoleRecursive3'


class RoleArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'RoleIncludeFromRoleRecursive4'


class RoleArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    
    

class FindManyRoleArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive1'


class FindManyRoleArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive2'


class FindManyRoleArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive3'


class FindManyRoleArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive4'


class FindManyRoleArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    
    

class TeamLeadersIncludeFromCommendation(TypedDict, total=False):
    """Relational arguments for Commendation"""
    member: Union[bool, 'MemberArgsFromCommendationRecursive1']
    team: Union[bool, 'TeamArgsFromCommendationRecursive1']


class TeamLeadersIncludeFromCommendationRecursive1(TypedDict, total=False):
    """Relational arguments for Commendation"""
    member: Union[bool, 'MemberArgsFromCommendationRecursive2']
    team: Union[bool, 'TeamArgsFromCommendationRecursive2']


class TeamLeadersIncludeFromCommendationRecursive2(TypedDict, total=False):
    """Relational arguments for Commendation"""
    member: Union[bool, 'MemberArgsFromCommendationRecursive3']
    team: Union[bool, 'TeamArgsFromCommendationRecursive3']


class TeamLeadersIncludeFromCommendationRecursive3(TypedDict, total=False):
    """Relational arguments for Commendation"""
    member: Union[bool, 'MemberArgsFromCommendationRecursive4']
    team: Union[bool, 'TeamArgsFromCommendationRecursive4']


class TeamLeadersIncludeFromCommendationRecursive4(TypedDict, total=False):
    """Relational arguments for Commendation"""

    

class TeamLeadersArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class TeamLeadersArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class TeamLeadersArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class TeamLeadersArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class TeamLeadersArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    
    

class FindManyTeamLeadersArgsFromCommendation(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class FindManyTeamLeadersArgsFromCommendationRecursive1(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class FindManyTeamLeadersArgsFromCommendationRecursive2(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class FindManyTeamLeadersArgsFromCommendationRecursive3(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class FindManyTeamLeadersArgsFromCommendationRecursive4(TypedDict, total=False):
    """Arguments for Commendation"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    


FindManyCommendationArgs = FindManyCommendationArgsFromCommendation
FindFirstCommendationArgs = FindManyCommendationArgsFromCommendation


    

class CommendationWhereInput(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    recipientId: Union[_str, 'types.StringFilter']
    senderId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    recipient: 'MemberRelationFilter'
    sender: 'MemberRelationFilter'

    # should be noted that AND and NOT should be Union['CommendationWhereInputRecursive1', List['CommendationWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CommendationWhereInputRecursive1']
    OR: List['CommendationWhereInputRecursive1']
    NOT: List['CommendationWhereInputRecursive1']


class CommendationWhereInputRecursive1(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    recipientId: Union[_str, 'types.StringFilter']
    senderId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    recipient: 'MemberRelationFilter'
    sender: 'MemberRelationFilter'

    # should be noted that AND and NOT should be Union['CommendationWhereInputRecursive2', List['CommendationWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CommendationWhereInputRecursive2']
    OR: List['CommendationWhereInputRecursive2']
    NOT: List['CommendationWhereInputRecursive2']


class CommendationWhereInputRecursive2(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    recipientId: Union[_str, 'types.StringFilter']
    senderId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    recipient: 'MemberRelationFilter'
    sender: 'MemberRelationFilter'

    # should be noted that AND and NOT should be Union['CommendationWhereInputRecursive3', List['CommendationWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CommendationWhereInputRecursive3']
    OR: List['CommendationWhereInputRecursive3']
    NOT: List['CommendationWhereInputRecursive3']


class CommendationWhereInputRecursive3(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    recipientId: Union[_str, 'types.StringFilter']
    senderId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    recipient: 'MemberRelationFilter'
    sender: 'MemberRelationFilter'

    # should be noted that AND and NOT should be Union['CommendationWhereInputRecursive4', List['CommendationWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CommendationWhereInputRecursive4']
    OR: List['CommendationWhereInputRecursive4']
    NOT: List['CommendationWhereInputRecursive4']


class CommendationWhereInputRecursive4(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    recipientId: Union[_str, 'types.StringFilter']
    senderId: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    recipient: 'MemberRelationFilter'
    sender: 'MemberRelationFilter'



# aggregate Commendation types


    

class CommendationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    recipientId: Union[_str, 'types.StringWithAggregatesFilter']
    senderId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommendationScalarWhereWithAggregatesInputRecursive1']
    OR: List['CommendationScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CommendationScalarWhereWithAggregatesInputRecursive1']


class CommendationScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    recipientId: Union[_str, 'types.StringWithAggregatesFilter']
    senderId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommendationScalarWhereWithAggregatesInputRecursive2']
    OR: List['CommendationScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CommendationScalarWhereWithAggregatesInputRecursive2']


class CommendationScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    recipientId: Union[_str, 'types.StringWithAggregatesFilter']
    senderId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommendationScalarWhereWithAggregatesInputRecursive3']
    OR: List['CommendationScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CommendationScalarWhereWithAggregatesInputRecursive3']


class CommendationScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    recipientId: Union[_str, 'types.StringWithAggregatesFilter']
    senderId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommendationScalarWhereWithAggregatesInputRecursive4']
    OR: List['CommendationScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CommendationScalarWhereWithAggregatesInputRecursive4']


class CommendationScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Commendation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    recipientId: Union[_str, 'types.StringWithAggregatesFilter']
    senderId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class CommendationGroupByOutput(TypedDict, total=False):
    id: _str
    message: _str
    recipientId: _str
    senderId: _str
    createdAt: datetime.datetime
    _sum: 'CommendationSumAggregateOutput'
    _avg: 'CommendationAvgAggregateOutput'
    _min: 'CommendationMinAggregateOutput'
    _max: 'CommendationMaxAggregateOutput'
    _count: 'CommendationCountAggregateOutput'


class CommendationAvgAggregateOutput(TypedDict, total=False):
    """Commendation output for aggregating averages"""


class CommendationSumAggregateOutput(TypedDict, total=False):
    """Commendation output for aggregating sums"""


class CommendationScalarAggregateOutput(TypedDict, total=False):
    """Commendation output including scalar fields"""
    id: _str
    message: _str
    recipientId: _str
    senderId: _str
    createdAt: datetime.datetime


CommendationMinAggregateOutput = CommendationScalarAggregateOutput
CommendationMaxAggregateOutput = CommendationScalarAggregateOutput


class CommendationMaxAggregateInput(TypedDict, total=False):
    """Commendation input for aggregating by max"""
    id: bool
    message: bool
    recipientId: bool
    senderId: bool
    createdAt: bool


class CommendationMinAggregateInput(TypedDict, total=False):
    """Commendation input for aggregating by min"""
    id: bool
    message: bool
    recipientId: bool
    senderId: bool
    createdAt: bool


class CommendationNumberAggregateInput(TypedDict, total=False):
    """Commendation input for aggregating numbers"""


CommendationAvgAggregateInput = CommendationNumberAggregateInput
CommendationSumAggregateInput = CommendationNumberAggregateInput


CommendationCountAggregateInput = TypedDict(
    'CommendationCountAggregateInput',
    {
        'id': bool,
        'message': bool,
        'recipientId': bool,
        'senderId': bool,
        'createdAt': bool,
        '_all': bool,
    },
    total=False,
)

CommendationCountAggregateOutput = TypedDict(
    'CommendationCountAggregateOutput',
    {
        'id': int,
        'message': int,
        'recipientId': int,
        'senderId': int,
        'createdAt': int,
        '_all': int,
    },
    total=False,
)


CommendationKeys = Literal[
    'id',
    'message',
    'recipientId',
    'senderId',
    'createdAt',
    'recipient',
    'sender',
]
CommendationScalarFieldKeys = Literal[
    'id',
    'message',
    'recipientId',
    'senderId',
    'createdAt',
]
CommendationScalarFieldKeysT = TypeVar('CommendationScalarFieldKeysT', bound=CommendationScalarFieldKeys)

CommendationRelationalFieldKeys = Literal[
        'recipient',
        'sender',
    ]

# Member types

class MemberOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Member create method"""
    id: _str
    phone: Optional[_str]
    imageURL: Optional[_str]
    commendations: 'CommendationCreateManyNestedWithoutRelationsInput'
    sentCommendations: 'CommendationCreateManyNestedWithoutRelationsInput'
    leadsTeams: 'TeamLeadersCreateManyNestedWithoutRelationsInput'
    roles: 'RoleCreateManyNestedWithoutRelationsInput'
    teams: 'TeamCreateManyNestedWithoutRelationsInput'


class MemberCreateInput(MemberOptionalCreateInput):
    """Required arguments to the Member create method"""
    name: _str
    email: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MemberOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Member create method, without relations"""
    id: _str
    phone: Optional[_str]
    imageURL: Optional[_str]


class MemberCreateWithoutRelationsInput(MemberOptionalCreateWithoutRelationsInput):
    """Required arguments to the Member create method, without relations"""
    name: _str
    email: _str


class MemberCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MemberCreateWithoutRelationsInput'
    connect: 'MemberWhereUniqueInput'


class MemberCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MemberCreateWithoutRelationsInput', List['MemberCreateWithoutRelationsInput']]
    connect: Union['MemberWhereUniqueInput', List['MemberWhereUniqueInput']]


_MemberWhereUnique_id_Input = TypedDict(
    '_MemberWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_MemberWhereUnique_email_Input = TypedDict(
    '_MemberWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

MemberWhereUniqueInput = Union[
    '_MemberWhereUnique_id_Input',
    '_MemberWhereUnique_email_Input',
]


class MemberUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    email: _str
    phone: Optional[_str]
    imageURL: Optional[_str]
    commendations: 'CommendationUpdateManyWithoutRelationsInput'
    sentCommendations: 'CommendationUpdateManyWithoutRelationsInput'
    leadsTeams: 'TeamLeadersUpdateManyWithoutRelationsInput'
    roles: 'RoleUpdateManyWithoutRelationsInput'
    teams: 'TeamUpdateManyWithoutRelationsInput'


class MemberUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    email: _str
    phone: Optional[_str]
    imageURL: Optional[_str]


class MemberUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MemberCreateWithoutRelationsInput']
    connect: List['MemberWhereUniqueInput']
    set: List['MemberWhereUniqueInput']
    disconnect: List['MemberWhereUniqueInput']
    delete: List['MemberWhereUniqueInput']

    # TODO
    # update: List['MemberUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MemberUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MemberScalarWhereInput']
    # upsert: List['MemberUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['MemberCreateOrConnectWithoutRelationsInput']


class MemberUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MemberCreateWithoutRelationsInput'
    connect: 'MemberWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MemberUpdateInput'
    # upsert: 'MemberUpsertWithoutRelationsInput'
    # connectOrCreate: 'MemberCreateOrConnectWithoutRelationsInput'


class MemberUpsertInput(TypedDict):
    create: 'MemberCreateInput'
    update: 'MemberUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Member_id_OrderByInput = TypedDict(
    '_Member_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Member_name_OrderByInput = TypedDict(
    '_Member_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Member_email_OrderByInput = TypedDict(
    '_Member_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Member_phone_OrderByInput = TypedDict(
    '_Member_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Member_imageURL_OrderByInput = TypedDict(
    '_Member_imageURL_OrderByInput',
    {
        'imageURL': 'SortOrder',
    },
    total=True
)

MemberOrderByInput = Union[
    '_Member_id_OrderByInput',
    '_Member_name_OrderByInput',
    '_Member_email_OrderByInput',
    '_Member_phone_OrderByInput',
    '_Member_imageURL_OrderByInput',
]



# recursive Member types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MemberRelationFilter = TypedDict(
    'MemberRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MemberListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MemberInclude(TypedDict, total=False):
    """Member relational arguments"""
    commendations: Union[bool, 'FindManyCommendationArgsFromMember']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromMember']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromMember']
    roles: Union[bool, 'FindManyRoleArgsFromMember']
    teams: Union[bool, 'FindManyTeamArgsFromMember']


    

class CommendationIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    recipient: Union[bool, 'MemberArgsFromMemberRecursive1']
    sender: Union[bool, 'MemberArgsFromMemberRecursive1']


class CommendationIncludeFromMemberRecursive1(TypedDict, total=False):
    """Relational arguments for Member"""
    recipient: Union[bool, 'MemberArgsFromMemberRecursive2']
    sender: Union[bool, 'MemberArgsFromMemberRecursive2']


class CommendationIncludeFromMemberRecursive2(TypedDict, total=False):
    """Relational arguments for Member"""
    recipient: Union[bool, 'MemberArgsFromMemberRecursive3']
    sender: Union[bool, 'MemberArgsFromMemberRecursive3']


class CommendationIncludeFromMemberRecursive3(TypedDict, total=False):
    """Relational arguments for Member"""
    recipient: Union[bool, 'MemberArgsFromMemberRecursive4']
    sender: Union[bool, 'MemberArgsFromMemberRecursive4']


class CommendationIncludeFromMemberRecursive4(TypedDict, total=False):
    """Relational arguments for Member"""

    

class CommendationArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'CommendationIncludeFromCommendationRecursive1'


class CommendationArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    include: 'CommendationIncludeFromCommendationRecursive2'


class CommendationArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    include: 'CommendationIncludeFromCommendationRecursive3'


class CommendationArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    include: 'CommendationIncludeFromCommendationRecursive4'


class CommendationArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    
    

class FindManyCommendationArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive1'


class FindManyCommendationArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive2'


class FindManyCommendationArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive3'


class FindManyCommendationArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive4'


class FindManyCommendationArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    
    

class MemberIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    commendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive1']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive1']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive1']
    roles: Union[bool, 'FindManyRoleArgsFromMemberRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromMemberRecursive1']


class MemberIncludeFromMemberRecursive1(TypedDict, total=False):
    """Relational arguments for Member"""
    commendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive2']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive2']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive2']
    roles: Union[bool, 'FindManyRoleArgsFromMemberRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromMemberRecursive2']


class MemberIncludeFromMemberRecursive2(TypedDict, total=False):
    """Relational arguments for Member"""
    commendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive3']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive3']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive3']
    roles: Union[bool, 'FindManyRoleArgsFromMemberRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromMemberRecursive3']


class MemberIncludeFromMemberRecursive3(TypedDict, total=False):
    """Relational arguments for Member"""
    commendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive4']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromMemberRecursive4']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive4']
    roles: Union[bool, 'FindManyRoleArgsFromMemberRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromMemberRecursive4']


class MemberIncludeFromMemberRecursive4(TypedDict, total=False):
    """Relational arguments for Member"""

    

class MemberArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'MemberIncludeFromMemberRecursive1'


class MemberArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    include: 'MemberIncludeFromMemberRecursive2'


class MemberArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    include: 'MemberIncludeFromMemberRecursive3'


class MemberArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    include: 'MemberIncludeFromMemberRecursive4'


class MemberArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    
    

class FindManyMemberArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive1'


class FindManyMemberArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive2'


class FindManyMemberArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive3'


class FindManyMemberArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive4'


class FindManyMemberArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    
    

class TeamIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive1']
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive1']


class TeamIncludeFromMemberRecursive1(TypedDict, total=False):
    """Relational arguments for Member"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive2']
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive2']


class TeamIncludeFromMemberRecursive2(TypedDict, total=False):
    """Relational arguments for Member"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive3']
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive3']


class TeamIncludeFromMemberRecursive3(TypedDict, total=False):
    """Relational arguments for Member"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromMemberRecursive4']
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive4']


class TeamIncludeFromMemberRecursive4(TypedDict, total=False):
    """Relational arguments for Member"""

    

class TeamArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    
    

class FindManyTeamArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class RoleIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive1']


class RoleIncludeFromMemberRecursive1(TypedDict, total=False):
    """Relational arguments for Member"""
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive2']


class RoleIncludeFromMemberRecursive2(TypedDict, total=False):
    """Relational arguments for Member"""
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive3']


class RoleIncludeFromMemberRecursive3(TypedDict, total=False):
    """Relational arguments for Member"""
    members: Union[bool, 'FindManyMemberArgsFromMemberRecursive4']


class RoleIncludeFromMemberRecursive4(TypedDict, total=False):
    """Relational arguments for Member"""

    

class RoleArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'RoleIncludeFromRoleRecursive1'


class RoleArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    include: 'RoleIncludeFromRoleRecursive2'


class RoleArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    include: 'RoleIncludeFromRoleRecursive3'


class RoleArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    include: 'RoleIncludeFromRoleRecursive4'


class RoleArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    
    

class FindManyRoleArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive1'


class FindManyRoleArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive2'


class FindManyRoleArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive3'


class FindManyRoleArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive4'


class FindManyRoleArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    
    

class TeamLeadersIncludeFromMember(TypedDict, total=False):
    """Relational arguments for Member"""
    member: Union[bool, 'MemberArgsFromMemberRecursive1']
    team: Union[bool, 'TeamArgsFromMemberRecursive1']


class TeamLeadersIncludeFromMemberRecursive1(TypedDict, total=False):
    """Relational arguments for Member"""
    member: Union[bool, 'MemberArgsFromMemberRecursive2']
    team: Union[bool, 'TeamArgsFromMemberRecursive2']


class TeamLeadersIncludeFromMemberRecursive2(TypedDict, total=False):
    """Relational arguments for Member"""
    member: Union[bool, 'MemberArgsFromMemberRecursive3']
    team: Union[bool, 'TeamArgsFromMemberRecursive3']


class TeamLeadersIncludeFromMemberRecursive3(TypedDict, total=False):
    """Relational arguments for Member"""
    member: Union[bool, 'MemberArgsFromMemberRecursive4']
    team: Union[bool, 'TeamArgsFromMemberRecursive4']


class TeamLeadersIncludeFromMemberRecursive4(TypedDict, total=False):
    """Relational arguments for Member"""

    

class TeamLeadersArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class TeamLeadersArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class TeamLeadersArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class TeamLeadersArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class TeamLeadersArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    
    

class FindManyTeamLeadersArgsFromMember(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class FindManyTeamLeadersArgsFromMemberRecursive1(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class FindManyTeamLeadersArgsFromMemberRecursive2(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class FindManyTeamLeadersArgsFromMemberRecursive3(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class FindManyTeamLeadersArgsFromMemberRecursive4(TypedDict, total=False):
    """Arguments for Member"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    


FindManyMemberArgs = FindManyMemberArgsFromMember
FindFirstMemberArgs = FindManyMemberArgsFromMember


    

class MemberWhereInput(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    commendations: 'CommendationListRelationFilter'
    sentCommendations: 'CommendationListRelationFilter'
    leadsTeams: 'TeamLeadersListRelationFilter'
    roles: 'RoleListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['MemberWhereInputRecursive1', List['MemberWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MemberWhereInputRecursive1']
    OR: List['MemberWhereInputRecursive1']
    NOT: List['MemberWhereInputRecursive1']


class MemberWhereInputRecursive1(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    commendations: 'CommendationListRelationFilter'
    sentCommendations: 'CommendationListRelationFilter'
    leadsTeams: 'TeamLeadersListRelationFilter'
    roles: 'RoleListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['MemberWhereInputRecursive2', List['MemberWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MemberWhereInputRecursive2']
    OR: List['MemberWhereInputRecursive2']
    NOT: List['MemberWhereInputRecursive2']


class MemberWhereInputRecursive2(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    commendations: 'CommendationListRelationFilter'
    sentCommendations: 'CommendationListRelationFilter'
    leadsTeams: 'TeamLeadersListRelationFilter'
    roles: 'RoleListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['MemberWhereInputRecursive3', List['MemberWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MemberWhereInputRecursive3']
    OR: List['MemberWhereInputRecursive3']
    NOT: List['MemberWhereInputRecursive3']


class MemberWhereInputRecursive3(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    commendations: 'CommendationListRelationFilter'
    sentCommendations: 'CommendationListRelationFilter'
    leadsTeams: 'TeamLeadersListRelationFilter'
    roles: 'RoleListRelationFilter'
    teams: 'TeamListRelationFilter'

    # should be noted that AND and NOT should be Union['MemberWhereInputRecursive4', List['MemberWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MemberWhereInputRecursive4']
    OR: List['MemberWhereInputRecursive4']
    NOT: List['MemberWhereInputRecursive4']


class MemberWhereInputRecursive4(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    commendations: 'CommendationListRelationFilter'
    sentCommendations: 'CommendationListRelationFilter'
    leadsTeams: 'TeamLeadersListRelationFilter'
    roles: 'RoleListRelationFilter'
    teams: 'TeamListRelationFilter'



# aggregate Member types


    

class MemberScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MemberScalarWhereWithAggregatesInputRecursive1']
    OR: List['MemberScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MemberScalarWhereWithAggregatesInputRecursive1']


class MemberScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MemberScalarWhereWithAggregatesInputRecursive2']
    OR: List['MemberScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MemberScalarWhereWithAggregatesInputRecursive2']


class MemberScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MemberScalarWhereWithAggregatesInputRecursive3']
    OR: List['MemberScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MemberScalarWhereWithAggregatesInputRecursive3']


class MemberScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MemberScalarWhereWithAggregatesInputRecursive4']
    OR: List['MemberScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MemberScalarWhereWithAggregatesInputRecursive4']


class MemberScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Member arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']



class MemberGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    email: _str
    phone: _str
    imageURL: _str
    _sum: 'MemberSumAggregateOutput'
    _avg: 'MemberAvgAggregateOutput'
    _min: 'MemberMinAggregateOutput'
    _max: 'MemberMaxAggregateOutput'
    _count: 'MemberCountAggregateOutput'


class MemberAvgAggregateOutput(TypedDict, total=False):
    """Member output for aggregating averages"""


class MemberSumAggregateOutput(TypedDict, total=False):
    """Member output for aggregating sums"""


class MemberScalarAggregateOutput(TypedDict, total=False):
    """Member output including scalar fields"""
    id: _str
    name: _str
    email: _str
    phone: _str
    imageURL: _str


MemberMinAggregateOutput = MemberScalarAggregateOutput
MemberMaxAggregateOutput = MemberScalarAggregateOutput


class MemberMaxAggregateInput(TypedDict, total=False):
    """Member input for aggregating by max"""
    id: bool
    name: bool
    email: bool
    phone: bool
    imageURL: bool


class MemberMinAggregateInput(TypedDict, total=False):
    """Member input for aggregating by min"""
    id: bool
    name: bool
    email: bool
    phone: bool
    imageURL: bool


class MemberNumberAggregateInput(TypedDict, total=False):
    """Member input for aggregating numbers"""


MemberAvgAggregateInput = MemberNumberAggregateInput
MemberSumAggregateInput = MemberNumberAggregateInput


MemberCountAggregateInput = TypedDict(
    'MemberCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'email': bool,
        'phone': bool,
        'imageURL': bool,
        '_all': bool,
    },
    total=False,
)

MemberCountAggregateOutput = TypedDict(
    'MemberCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'email': int,
        'phone': int,
        'imageURL': int,
        '_all': int,
    },
    total=False,
)


MemberKeys = Literal[
    'id',
    'name',
    'email',
    'phone',
    'imageURL',
    'commendations',
    'sentCommendations',
    'leadsTeams',
    'roles',
    'teams',
]
MemberScalarFieldKeys = Literal[
    'id',
    'name',
    'email',
    'phone',
    'imageURL',
]
MemberScalarFieldKeysT = TypeVar('MemberScalarFieldKeysT', bound=MemberScalarFieldKeys)

MemberRelationalFieldKeys = Literal[
        'commendations',
        'sentCommendations',
        'leadsTeams',
        'roles',
        'teams',
    ]

# Team types

class TeamOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Team create method"""
    id: _str
    imageURL: Optional[_str]
    teamLeaders: 'TeamLeadersCreateManyNestedWithoutRelationsInput'
    members: 'MemberCreateManyNestedWithoutRelationsInput'


class TeamCreateInput(TeamOptionalCreateInput):
    """Required arguments to the Team create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Team create method, without relations"""
    id: _str
    imageURL: Optional[_str]


class TeamCreateWithoutRelationsInput(TeamOptionalCreateWithoutRelationsInput):
    """Required arguments to the Team create method, without relations"""
    name: _str


class TeamCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'


class TeamCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamCreateWithoutRelationsInput', List['TeamCreateWithoutRelationsInput']]
    connect: Union['TeamWhereUniqueInput', List['TeamWhereUniqueInput']]


_TeamWhereUnique_id_Input = TypedDict(
    '_TeamWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TeamWhereUniqueInput = _TeamWhereUnique_id_Input


class TeamUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    imageURL: Optional[_str]
    teamLeaders: 'TeamLeadersUpdateManyWithoutRelationsInput'
    members: 'MemberUpdateManyWithoutRelationsInput'


class TeamUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    imageURL: Optional[_str]


class TeamUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamCreateWithoutRelationsInput']
    connect: List['TeamWhereUniqueInput']
    set: List['TeamWhereUniqueInput']
    disconnect: List['TeamWhereUniqueInput']
    delete: List['TeamWhereUniqueInput']

    # TODO
    # update: List['TeamUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamScalarWhereInput']
    # upsert: List['TeamUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['TeamCreateOrConnectWithoutRelationsInput']


class TeamUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamUpdateInput'
    # upsert: 'TeamUpsertWithoutRelationsInput'
    # connectOrCreate: 'TeamCreateOrConnectWithoutRelationsInput'


class TeamUpsertInput(TypedDict):
    create: 'TeamCreateInput'
    update: 'TeamUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Team_id_OrderByInput = TypedDict(
    '_Team_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Team_name_OrderByInput = TypedDict(
    '_Team_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Team_imageURL_OrderByInput = TypedDict(
    '_Team_imageURL_OrderByInput',
    {
        'imageURL': 'SortOrder',
    },
    total=True
)

TeamOrderByInput = Union[
    '_Team_id_OrderByInput',
    '_Team_name_OrderByInput',
    '_Team_imageURL_OrderByInput',
]



# recursive Team types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TeamRelationFilter = TypedDict(
    'TeamRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TeamListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TeamInclude(TypedDict, total=False):
    """Team relational arguments"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeam']
    members: Union[bool, 'FindManyMemberArgsFromTeam']


    

class CommendationIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    recipient: Union[bool, 'MemberArgsFromTeamRecursive1']
    sender: Union[bool, 'MemberArgsFromTeamRecursive1']


class CommendationIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    recipient: Union[bool, 'MemberArgsFromTeamRecursive2']
    sender: Union[bool, 'MemberArgsFromTeamRecursive2']


class CommendationIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    recipient: Union[bool, 'MemberArgsFromTeamRecursive3']
    sender: Union[bool, 'MemberArgsFromTeamRecursive3']


class CommendationIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    recipient: Union[bool, 'MemberArgsFromTeamRecursive4']
    sender: Union[bool, 'MemberArgsFromTeamRecursive4']


class CommendationIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class CommendationArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CommendationIncludeFromCommendationRecursive1'


class CommendationArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CommendationIncludeFromCommendationRecursive2'


class CommendationArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CommendationIncludeFromCommendationRecursive3'


class CommendationArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CommendationIncludeFromCommendationRecursive4'


class CommendationArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyCommendationArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive1'


class FindManyCommendationArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive2'


class FindManyCommendationArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive3'


class FindManyCommendationArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive4'


class FindManyCommendationArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    
    

class MemberIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive1']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive1']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive1']
    roles: Union[bool, 'FindManyRoleArgsFromTeamRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive1']


class MemberIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive2']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive2']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive2']
    roles: Union[bool, 'FindManyRoleArgsFromTeamRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive2']


class MemberIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive3']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive3']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive3']
    roles: Union[bool, 'FindManyRoleArgsFromTeamRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive3']


class MemberIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive4']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamRecursive4']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive4']
    roles: Union[bool, 'FindManyRoleArgsFromTeamRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive4']


class MemberIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class MemberArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MemberIncludeFromMemberRecursive1'


class MemberArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MemberIncludeFromMemberRecursive2'


class MemberArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MemberIncludeFromMemberRecursive3'


class MemberArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MemberIncludeFromMemberRecursive4'


class MemberArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyMemberArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive1'


class FindManyMemberArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive2'


class FindManyMemberArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive3'


class FindManyMemberArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive4'


class FindManyMemberArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    
    

class TeamIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive1']
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive1']


class TeamIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive2']
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive2']


class TeamIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive3']
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive3']


class TeamIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamRecursive4']
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive4']


class TeamIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class TeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyTeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class RoleIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive1']


class RoleIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive2']


class RoleIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive3']


class RoleIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    members: Union[bool, 'FindManyMemberArgsFromTeamRecursive4']


class RoleIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class RoleArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'RoleIncludeFromRoleRecursive1'


class RoleArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'RoleIncludeFromRoleRecursive2'


class RoleArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'RoleIncludeFromRoleRecursive3'


class RoleArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'RoleIncludeFromRoleRecursive4'


class RoleArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyRoleArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive1'


class FindManyRoleArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive2'


class FindManyRoleArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive3'


class FindManyRoleArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive4'


class FindManyRoleArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    
    

class TeamLeadersIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    member: Union[bool, 'MemberArgsFromTeamRecursive1']
    team: Union[bool, 'TeamArgsFromTeamRecursive1']


class TeamLeadersIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    member: Union[bool, 'MemberArgsFromTeamRecursive2']
    team: Union[bool, 'TeamArgsFromTeamRecursive2']


class TeamLeadersIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    member: Union[bool, 'MemberArgsFromTeamRecursive3']
    team: Union[bool, 'TeamArgsFromTeamRecursive3']


class TeamLeadersIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    member: Union[bool, 'MemberArgsFromTeamRecursive4']
    team: Union[bool, 'TeamArgsFromTeamRecursive4']


class TeamLeadersIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class TeamLeadersArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class TeamLeadersArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class TeamLeadersArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class TeamLeadersArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class TeamLeadersArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyTeamLeadersArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class FindManyTeamLeadersArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class FindManyTeamLeadersArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class FindManyTeamLeadersArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class FindManyTeamLeadersArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    


FindManyTeamArgs = FindManyTeamArgsFromTeam
FindFirstTeamArgs = FindManyTeamArgsFromTeam


    

class TeamWhereInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    teamLeaders: 'TeamLeadersListRelationFilter'
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive1', List['TeamWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive1']
    OR: List['TeamWhereInputRecursive1']
    NOT: List['TeamWhereInputRecursive1']


class TeamWhereInputRecursive1(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    teamLeaders: 'TeamLeadersListRelationFilter'
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive2', List['TeamWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive2']
    OR: List['TeamWhereInputRecursive2']
    NOT: List['TeamWhereInputRecursive2']


class TeamWhereInputRecursive2(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    teamLeaders: 'TeamLeadersListRelationFilter'
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive3', List['TeamWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive3']
    OR: List['TeamWhereInputRecursive3']
    NOT: List['TeamWhereInputRecursive3']


class TeamWhereInputRecursive3(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    teamLeaders: 'TeamLeadersListRelationFilter'
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive4', List['TeamWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive4']
    OR: List['TeamWhereInputRecursive4']
    NOT: List['TeamWhereInputRecursive4']


class TeamWhereInputRecursive4(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    imageURL: Union[None, _str, 'types.StringFilter']
    teamLeaders: 'TeamLeadersListRelationFilter'
    members: 'MemberListRelationFilter'



# aggregate Team types


    

class TeamScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive1']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive1']


class TeamScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive2']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive2']


class TeamScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive3']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive3']


class TeamScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive4']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive4']


class TeamScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    imageURL: Union[_str, 'types.StringWithAggregatesFilter']



class TeamGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    imageURL: _str
    _sum: 'TeamSumAggregateOutput'
    _avg: 'TeamAvgAggregateOutput'
    _min: 'TeamMinAggregateOutput'
    _max: 'TeamMaxAggregateOutput'
    _count: 'TeamCountAggregateOutput'


class TeamAvgAggregateOutput(TypedDict, total=False):
    """Team output for aggregating averages"""


class TeamSumAggregateOutput(TypedDict, total=False):
    """Team output for aggregating sums"""


class TeamScalarAggregateOutput(TypedDict, total=False):
    """Team output including scalar fields"""
    id: _str
    name: _str
    imageURL: _str


TeamMinAggregateOutput = TeamScalarAggregateOutput
TeamMaxAggregateOutput = TeamScalarAggregateOutput


class TeamMaxAggregateInput(TypedDict, total=False):
    """Team input for aggregating by max"""
    id: bool
    name: bool
    imageURL: bool


class TeamMinAggregateInput(TypedDict, total=False):
    """Team input for aggregating by min"""
    id: bool
    name: bool
    imageURL: bool


class TeamNumberAggregateInput(TypedDict, total=False):
    """Team input for aggregating numbers"""


TeamAvgAggregateInput = TeamNumberAggregateInput
TeamSumAggregateInput = TeamNumberAggregateInput


TeamCountAggregateInput = TypedDict(
    'TeamCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'imageURL': bool,
        '_all': bool,
    },
    total=False,
)

TeamCountAggregateOutput = TypedDict(
    'TeamCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'imageURL': int,
        '_all': int,
    },
    total=False,
)


TeamKeys = Literal[
    'id',
    'name',
    'imageURL',
    'teamLeaders',
    'members',
]
TeamScalarFieldKeys = Literal[
    'id',
    'name',
    'imageURL',
]
TeamScalarFieldKeysT = TypeVar('TeamScalarFieldKeysT', bound=TeamScalarFieldKeys)

TeamRelationalFieldKeys = Literal[
        'teamLeaders',
        'members',
    ]

# Role types

class RoleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Role create method"""
    id: _str
    members: 'MemberCreateManyNestedWithoutRelationsInput'


class RoleCreateInput(RoleOptionalCreateInput):
    """Required arguments to the Role create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class RoleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Role create method, without relations"""
    id: _str


class RoleCreateWithoutRelationsInput(RoleOptionalCreateWithoutRelationsInput):
    """Required arguments to the Role create method, without relations"""
    name: _str


class RoleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'RoleCreateWithoutRelationsInput'
    connect: 'RoleWhereUniqueInput'


class RoleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['RoleCreateWithoutRelationsInput', List['RoleCreateWithoutRelationsInput']]
    connect: Union['RoleWhereUniqueInput', List['RoleWhereUniqueInput']]


_RoleWhereUnique_id_Input = TypedDict(
    '_RoleWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

RoleWhereUniqueInput = _RoleWhereUnique_id_Input


class RoleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    members: 'MemberUpdateManyWithoutRelationsInput'


class RoleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str


class RoleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['RoleCreateWithoutRelationsInput']
    connect: List['RoleWhereUniqueInput']
    set: List['RoleWhereUniqueInput']
    disconnect: List['RoleWhereUniqueInput']
    delete: List['RoleWhereUniqueInput']

    # TODO
    # update: List['RoleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['RoleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['RoleScalarWhereInput']
    # upsert: List['RoleUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['RoleCreateOrConnectWithoutRelationsInput']


class RoleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'RoleCreateWithoutRelationsInput'
    connect: 'RoleWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'RoleUpdateInput'
    # upsert: 'RoleUpsertWithoutRelationsInput'
    # connectOrCreate: 'RoleCreateOrConnectWithoutRelationsInput'


class RoleUpsertInput(TypedDict):
    create: 'RoleCreateInput'
    update: 'RoleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Role_id_OrderByInput = TypedDict(
    '_Role_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Role_name_OrderByInput = TypedDict(
    '_Role_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

RoleOrderByInput = Union[
    '_Role_id_OrderByInput',
    '_Role_name_OrderByInput',
]



# recursive Role types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

RoleRelationFilter = TypedDict(
    'RoleRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class RoleListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class RoleInclude(TypedDict, total=False):
    """Role relational arguments"""
    members: Union[bool, 'FindManyMemberArgsFromRole']


    

class CommendationIncludeFromRole(TypedDict, total=False):
    """Relational arguments for Role"""
    recipient: Union[bool, 'MemberArgsFromRoleRecursive1']
    sender: Union[bool, 'MemberArgsFromRoleRecursive1']


class CommendationIncludeFromRoleRecursive1(TypedDict, total=False):
    """Relational arguments for Role"""
    recipient: Union[bool, 'MemberArgsFromRoleRecursive2']
    sender: Union[bool, 'MemberArgsFromRoleRecursive2']


class CommendationIncludeFromRoleRecursive2(TypedDict, total=False):
    """Relational arguments for Role"""
    recipient: Union[bool, 'MemberArgsFromRoleRecursive3']
    sender: Union[bool, 'MemberArgsFromRoleRecursive3']


class CommendationIncludeFromRoleRecursive3(TypedDict, total=False):
    """Relational arguments for Role"""
    recipient: Union[bool, 'MemberArgsFromRoleRecursive4']
    sender: Union[bool, 'MemberArgsFromRoleRecursive4']


class CommendationIncludeFromRoleRecursive4(TypedDict, total=False):
    """Relational arguments for Role"""

    

class CommendationArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    include: 'CommendationIncludeFromCommendationRecursive1'


class CommendationArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    include: 'CommendationIncludeFromCommendationRecursive2'


class CommendationArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    include: 'CommendationIncludeFromCommendationRecursive3'


class CommendationArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    include: 'CommendationIncludeFromCommendationRecursive4'


class CommendationArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    
    

class FindManyCommendationArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive1'


class FindManyCommendationArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive2'


class FindManyCommendationArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive3'


class FindManyCommendationArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive4'


class FindManyCommendationArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    
    

class MemberIncludeFromRole(TypedDict, total=False):
    """Relational arguments for Role"""
    commendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive1']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive1']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive1']
    roles: Union[bool, 'FindManyRoleArgsFromRoleRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromRoleRecursive1']


class MemberIncludeFromRoleRecursive1(TypedDict, total=False):
    """Relational arguments for Role"""
    commendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive2']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive2']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive2']
    roles: Union[bool, 'FindManyRoleArgsFromRoleRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromRoleRecursive2']


class MemberIncludeFromRoleRecursive2(TypedDict, total=False):
    """Relational arguments for Role"""
    commendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive3']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive3']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive3']
    roles: Union[bool, 'FindManyRoleArgsFromRoleRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromRoleRecursive3']


class MemberIncludeFromRoleRecursive3(TypedDict, total=False):
    """Relational arguments for Role"""
    commendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive4']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromRoleRecursive4']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive4']
    roles: Union[bool, 'FindManyRoleArgsFromRoleRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromRoleRecursive4']


class MemberIncludeFromRoleRecursive4(TypedDict, total=False):
    """Relational arguments for Role"""

    

class MemberArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    include: 'MemberIncludeFromMemberRecursive1'


class MemberArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    include: 'MemberIncludeFromMemberRecursive2'


class MemberArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    include: 'MemberIncludeFromMemberRecursive3'


class MemberArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    include: 'MemberIncludeFromMemberRecursive4'


class MemberArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    
    

class FindManyMemberArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive1'


class FindManyMemberArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive2'


class FindManyMemberArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive3'


class FindManyMemberArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive4'


class FindManyMemberArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    
    

class TeamIncludeFromRole(TypedDict, total=False):
    """Relational arguments for Role"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive1']
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive1']


class TeamIncludeFromRoleRecursive1(TypedDict, total=False):
    """Relational arguments for Role"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive2']
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive2']


class TeamIncludeFromRoleRecursive2(TypedDict, total=False):
    """Relational arguments for Role"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive3']
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive3']


class TeamIncludeFromRoleRecursive3(TypedDict, total=False):
    """Relational arguments for Role"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromRoleRecursive4']
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive4']


class TeamIncludeFromRoleRecursive4(TypedDict, total=False):
    """Relational arguments for Role"""

    

class TeamArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    
    

class FindManyTeamArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class RoleIncludeFromRole(TypedDict, total=False):
    """Relational arguments for Role"""
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive1']


class RoleIncludeFromRoleRecursive1(TypedDict, total=False):
    """Relational arguments for Role"""
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive2']


class RoleIncludeFromRoleRecursive2(TypedDict, total=False):
    """Relational arguments for Role"""
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive3']


class RoleIncludeFromRoleRecursive3(TypedDict, total=False):
    """Relational arguments for Role"""
    members: Union[bool, 'FindManyMemberArgsFromRoleRecursive4']


class RoleIncludeFromRoleRecursive4(TypedDict, total=False):
    """Relational arguments for Role"""

    

class RoleArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    include: 'RoleIncludeFromRoleRecursive1'


class RoleArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    include: 'RoleIncludeFromRoleRecursive2'


class RoleArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    include: 'RoleIncludeFromRoleRecursive3'


class RoleArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    include: 'RoleIncludeFromRoleRecursive4'


class RoleArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    
    

class FindManyRoleArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive1'


class FindManyRoleArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive2'


class FindManyRoleArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive3'


class FindManyRoleArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive4'


class FindManyRoleArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    
    

class TeamLeadersIncludeFromRole(TypedDict, total=False):
    """Relational arguments for Role"""
    member: Union[bool, 'MemberArgsFromRoleRecursive1']
    team: Union[bool, 'TeamArgsFromRoleRecursive1']


class TeamLeadersIncludeFromRoleRecursive1(TypedDict, total=False):
    """Relational arguments for Role"""
    member: Union[bool, 'MemberArgsFromRoleRecursive2']
    team: Union[bool, 'TeamArgsFromRoleRecursive2']


class TeamLeadersIncludeFromRoleRecursive2(TypedDict, total=False):
    """Relational arguments for Role"""
    member: Union[bool, 'MemberArgsFromRoleRecursive3']
    team: Union[bool, 'TeamArgsFromRoleRecursive3']


class TeamLeadersIncludeFromRoleRecursive3(TypedDict, total=False):
    """Relational arguments for Role"""
    member: Union[bool, 'MemberArgsFromRoleRecursive4']
    team: Union[bool, 'TeamArgsFromRoleRecursive4']


class TeamLeadersIncludeFromRoleRecursive4(TypedDict, total=False):
    """Relational arguments for Role"""

    

class TeamLeadersArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class TeamLeadersArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class TeamLeadersArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class TeamLeadersArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class TeamLeadersArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    
    

class FindManyTeamLeadersArgsFromRole(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class FindManyTeamLeadersArgsFromRoleRecursive1(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class FindManyTeamLeadersArgsFromRoleRecursive2(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class FindManyTeamLeadersArgsFromRoleRecursive3(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class FindManyTeamLeadersArgsFromRoleRecursive4(TypedDict, total=False):
    """Arguments for Role"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    


FindManyRoleArgs = FindManyRoleArgsFromRole
FindFirstRoleArgs = FindManyRoleArgsFromRole


    

class RoleWhereInput(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['RoleWhereInputRecursive1', List['RoleWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['RoleWhereInputRecursive1']
    OR: List['RoleWhereInputRecursive1']
    NOT: List['RoleWhereInputRecursive1']


class RoleWhereInputRecursive1(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['RoleWhereInputRecursive2', List['RoleWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['RoleWhereInputRecursive2']
    OR: List['RoleWhereInputRecursive2']
    NOT: List['RoleWhereInputRecursive2']


class RoleWhereInputRecursive2(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['RoleWhereInputRecursive3', List['RoleWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['RoleWhereInputRecursive3']
    OR: List['RoleWhereInputRecursive3']
    NOT: List['RoleWhereInputRecursive3']


class RoleWhereInputRecursive3(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    members: 'MemberListRelationFilter'

    # should be noted that AND and NOT should be Union['RoleWhereInputRecursive4', List['RoleWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['RoleWhereInputRecursive4']
    OR: List['RoleWhereInputRecursive4']
    NOT: List['RoleWhereInputRecursive4']


class RoleWhereInputRecursive4(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    members: 'MemberListRelationFilter'



# aggregate Role types


    

class RoleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RoleScalarWhereWithAggregatesInputRecursive1']
    OR: List['RoleScalarWhereWithAggregatesInputRecursive1']
    NOT: List['RoleScalarWhereWithAggregatesInputRecursive1']


class RoleScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RoleScalarWhereWithAggregatesInputRecursive2']
    OR: List['RoleScalarWhereWithAggregatesInputRecursive2']
    NOT: List['RoleScalarWhereWithAggregatesInputRecursive2']


class RoleScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RoleScalarWhereWithAggregatesInputRecursive3']
    OR: List['RoleScalarWhereWithAggregatesInputRecursive3']
    NOT: List['RoleScalarWhereWithAggregatesInputRecursive3']


class RoleScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['RoleScalarWhereWithAggregatesInputRecursive4']
    OR: List['RoleScalarWhereWithAggregatesInputRecursive4']
    NOT: List['RoleScalarWhereWithAggregatesInputRecursive4']


class RoleScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Role arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']



class RoleGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    _sum: 'RoleSumAggregateOutput'
    _avg: 'RoleAvgAggregateOutput'
    _min: 'RoleMinAggregateOutput'
    _max: 'RoleMaxAggregateOutput'
    _count: 'RoleCountAggregateOutput'


class RoleAvgAggregateOutput(TypedDict, total=False):
    """Role output for aggregating averages"""


class RoleSumAggregateOutput(TypedDict, total=False):
    """Role output for aggregating sums"""


class RoleScalarAggregateOutput(TypedDict, total=False):
    """Role output including scalar fields"""
    id: _str
    name: _str


RoleMinAggregateOutput = RoleScalarAggregateOutput
RoleMaxAggregateOutput = RoleScalarAggregateOutput


class RoleMaxAggregateInput(TypedDict, total=False):
    """Role input for aggregating by max"""
    id: bool
    name: bool


class RoleMinAggregateInput(TypedDict, total=False):
    """Role input for aggregating by min"""
    id: bool
    name: bool


class RoleNumberAggregateInput(TypedDict, total=False):
    """Role input for aggregating numbers"""


RoleAvgAggregateInput = RoleNumberAggregateInput
RoleSumAggregateInput = RoleNumberAggregateInput


RoleCountAggregateInput = TypedDict(
    'RoleCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        '_all': bool,
    },
    total=False,
)

RoleCountAggregateOutput = TypedDict(
    'RoleCountAggregateOutput',
    {
        'id': int,
        'name': int,
        '_all': int,
    },
    total=False,
)


RoleKeys = Literal[
    'id',
    'name',
    'members',
]
RoleScalarFieldKeys = Literal[
    'id',
    'name',
]
RoleScalarFieldKeysT = TypeVar('RoleScalarFieldKeysT', bound=RoleScalarFieldKeys)

RoleRelationalFieldKeys = Literal[
        'members',
    ]

# TeamLeaders types

class TeamLeadersOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TeamLeaders create method"""
    id: _str
    memberId: _str
    teamId: _str
    member: 'MemberCreateNestedWithoutRelationsInput'
    team: 'TeamCreateNestedWithoutRelationsInput'


class TeamLeadersCreateInput(TeamLeadersOptionalCreateInput):
    """Required arguments to the TeamLeaders create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamLeadersOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TeamLeaders create method, without relations"""
    id: _str
    memberId: _str
    teamId: _str


class TeamLeadersCreateWithoutRelationsInput(TeamLeadersOptionalCreateWithoutRelationsInput):
    """Required arguments to the TeamLeaders create method, without relations"""


class TeamLeadersCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamLeadersCreateWithoutRelationsInput'
    connect: 'TeamLeadersWhereUniqueInput'


class TeamLeadersCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamLeadersCreateWithoutRelationsInput', List['TeamLeadersCreateWithoutRelationsInput']]
    connect: Union['TeamLeadersWhereUniqueInput', List['TeamLeadersWhereUniqueInput']]


_TeamLeadersWhereUnique_id_Input = TypedDict(
    '_TeamLeadersWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TeamLeadersWhereUniqueInput = _TeamLeadersWhereUnique_id_Input


class TeamLeadersUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    member: 'MemberUpdateOneWithoutRelationsInput'
    team: 'TeamUpdateOneWithoutRelationsInput'


class TeamLeadersUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str


class TeamLeadersUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamLeadersCreateWithoutRelationsInput']
    connect: List['TeamLeadersWhereUniqueInput']
    set: List['TeamLeadersWhereUniqueInput']
    disconnect: List['TeamLeadersWhereUniqueInput']
    delete: List['TeamLeadersWhereUniqueInput']

    # TODO
    # update: List['TeamLeadersUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamLeadersUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamLeadersScalarWhereInput']
    # upsert: List['TeamLeadersUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['TeamLeadersCreateOrConnectWithoutRelationsInput']


class TeamLeadersUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamLeadersCreateWithoutRelationsInput'
    connect: 'TeamLeadersWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamLeadersUpdateInput'
    # upsert: 'TeamLeadersUpsertWithoutRelationsInput'
    # connectOrCreate: 'TeamLeadersCreateOrConnectWithoutRelationsInput'


class TeamLeadersUpsertInput(TypedDict):
    create: 'TeamLeadersCreateInput'
    update: 'TeamLeadersUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TeamLeaders_id_OrderByInput = TypedDict(
    '_TeamLeaders_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TeamLeaders_memberId_OrderByInput = TypedDict(
    '_TeamLeaders_memberId_OrderByInput',
    {
        'memberId': 'SortOrder',
    },
    total=True
)

_TeamLeaders_teamId_OrderByInput = TypedDict(
    '_TeamLeaders_teamId_OrderByInput',
    {
        'teamId': 'SortOrder',
    },
    total=True
)

TeamLeadersOrderByInput = Union[
    '_TeamLeaders_id_OrderByInput',
    '_TeamLeaders_memberId_OrderByInput',
    '_TeamLeaders_teamId_OrderByInput',
]



# recursive TeamLeaders types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TeamLeadersRelationFilter = TypedDict(
    'TeamLeadersRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TeamLeadersListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TeamLeadersInclude(TypedDict, total=False):
    """TeamLeaders relational arguments"""
    member: Union[bool, 'MemberArgsFromTeamLeaders']
    team: Union[bool, 'TeamArgsFromTeamLeaders']


    

class CommendationIncludeFromTeamLeaders(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    recipient: Union[bool, 'MemberArgsFromTeamLeadersRecursive1']
    sender: Union[bool, 'MemberArgsFromTeamLeadersRecursive1']


class CommendationIncludeFromTeamLeadersRecursive1(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    recipient: Union[bool, 'MemberArgsFromTeamLeadersRecursive2']
    sender: Union[bool, 'MemberArgsFromTeamLeadersRecursive2']


class CommendationIncludeFromTeamLeadersRecursive2(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    recipient: Union[bool, 'MemberArgsFromTeamLeadersRecursive3']
    sender: Union[bool, 'MemberArgsFromTeamLeadersRecursive3']


class CommendationIncludeFromTeamLeadersRecursive3(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    recipient: Union[bool, 'MemberArgsFromTeamLeadersRecursive4']
    sender: Union[bool, 'MemberArgsFromTeamLeadersRecursive4']


class CommendationIncludeFromTeamLeadersRecursive4(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""

    

class CommendationArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'CommendationIncludeFromCommendationRecursive1'


class CommendationArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'CommendationIncludeFromCommendationRecursive2'


class CommendationArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'CommendationIncludeFromCommendationRecursive3'


class CommendationArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'CommendationIncludeFromCommendationRecursive4'


class CommendationArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    
    

class FindManyCommendationArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive1'


class FindManyCommendationArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive2'


class FindManyCommendationArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive3'


class FindManyCommendationArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    include: 'CommendationIncludeFromCommendationRecursive4'


class FindManyCommendationArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['CommendationOrderByInput', List['CommendationOrderByInput']]
    where: 'CommendationWhereInput'
    cursor: 'CommendationWhereUniqueInput'
    distinct: List['CommendationScalarFieldKeys']
    
    

class MemberIncludeFromTeamLeaders(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive1']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive1']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive1']
    roles: Union[bool, 'FindManyRoleArgsFromTeamLeadersRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamLeadersRecursive1']


class MemberIncludeFromTeamLeadersRecursive1(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive2']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive2']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive2']
    roles: Union[bool, 'FindManyRoleArgsFromTeamLeadersRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamLeadersRecursive2']


class MemberIncludeFromTeamLeadersRecursive2(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive3']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive3']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive3']
    roles: Union[bool, 'FindManyRoleArgsFromTeamLeadersRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamLeadersRecursive3']


class MemberIncludeFromTeamLeadersRecursive3(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    commendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive4']
    sentCommendations: Union[bool, 'FindManyCommendationArgsFromTeamLeadersRecursive4']
    leadsTeams: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive4']
    roles: Union[bool, 'FindManyRoleArgsFromTeamLeadersRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamLeadersRecursive4']


class MemberIncludeFromTeamLeadersRecursive4(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""

    

class MemberArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'MemberIncludeFromMemberRecursive1'


class MemberArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'MemberIncludeFromMemberRecursive2'


class MemberArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'MemberIncludeFromMemberRecursive3'


class MemberArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'MemberIncludeFromMemberRecursive4'


class MemberArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    
    

class FindManyMemberArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive1'


class FindManyMemberArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive2'


class FindManyMemberArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive3'


class FindManyMemberArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    include: 'MemberIncludeFromMemberRecursive4'


class FindManyMemberArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['MemberOrderByInput', List['MemberOrderByInput']]
    where: 'MemberWhereInput'
    cursor: 'MemberWhereUniqueInput'
    distinct: List['MemberScalarFieldKeys']
    
    

class TeamIncludeFromTeamLeaders(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive1']
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive1']


class TeamIncludeFromTeamLeadersRecursive1(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive2']
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive2']


class TeamIncludeFromTeamLeadersRecursive2(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive3']
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive3']


class TeamIncludeFromTeamLeadersRecursive3(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    teamLeaders: Union[bool, 'FindManyTeamLeadersArgsFromTeamLeadersRecursive4']
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive4']


class TeamIncludeFromTeamLeadersRecursive4(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""

    

class TeamArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    
    

class FindManyTeamArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class RoleIncludeFromTeamLeaders(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive1']


class RoleIncludeFromTeamLeadersRecursive1(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive2']


class RoleIncludeFromTeamLeadersRecursive2(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive3']


class RoleIncludeFromTeamLeadersRecursive3(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    members: Union[bool, 'FindManyMemberArgsFromTeamLeadersRecursive4']


class RoleIncludeFromTeamLeadersRecursive4(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""

    

class RoleArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'RoleIncludeFromRoleRecursive1'


class RoleArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'RoleIncludeFromRoleRecursive2'


class RoleArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'RoleIncludeFromRoleRecursive3'


class RoleArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'RoleIncludeFromRoleRecursive4'


class RoleArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    
    

class FindManyRoleArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive1'


class FindManyRoleArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive2'


class FindManyRoleArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive3'


class FindManyRoleArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    include: 'RoleIncludeFromRoleRecursive4'


class FindManyRoleArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['RoleOrderByInput', List['RoleOrderByInput']]
    where: 'RoleWhereInput'
    cursor: 'RoleWhereUniqueInput'
    distinct: List['RoleScalarFieldKeys']
    
    

class TeamLeadersIncludeFromTeamLeaders(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    member: Union[bool, 'MemberArgsFromTeamLeadersRecursive1']
    team: Union[bool, 'TeamArgsFromTeamLeadersRecursive1']


class TeamLeadersIncludeFromTeamLeadersRecursive1(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    member: Union[bool, 'MemberArgsFromTeamLeadersRecursive2']
    team: Union[bool, 'TeamArgsFromTeamLeadersRecursive2']


class TeamLeadersIncludeFromTeamLeadersRecursive2(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    member: Union[bool, 'MemberArgsFromTeamLeadersRecursive3']
    team: Union[bool, 'TeamArgsFromTeamLeadersRecursive3']


class TeamLeadersIncludeFromTeamLeadersRecursive3(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""
    member: Union[bool, 'MemberArgsFromTeamLeadersRecursive4']
    team: Union[bool, 'TeamArgsFromTeamLeadersRecursive4']


class TeamLeadersIncludeFromTeamLeadersRecursive4(TypedDict, total=False):
    """Relational arguments for TeamLeaders"""

    

class TeamLeadersArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class TeamLeadersArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class TeamLeadersArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class TeamLeadersArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class TeamLeadersArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    
    

class FindManyTeamLeadersArgsFromTeamLeaders(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive1'


class FindManyTeamLeadersArgsFromTeamLeadersRecursive1(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive2'


class FindManyTeamLeadersArgsFromTeamLeadersRecursive2(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive3'


class FindManyTeamLeadersArgsFromTeamLeadersRecursive3(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    include: 'TeamLeadersIncludeFromTeamLeadersRecursive4'


class FindManyTeamLeadersArgsFromTeamLeadersRecursive4(TypedDict, total=False):
    """Arguments for TeamLeaders"""
    take: int
    skip: int
    order_by: Union['TeamLeadersOrderByInput', List['TeamLeadersOrderByInput']]
    where: 'TeamLeadersWhereInput'
    cursor: 'TeamLeadersWhereUniqueInput'
    distinct: List['TeamLeadersScalarFieldKeys']
    


FindManyTeamLeadersArgs = FindManyTeamLeadersArgsFromTeamLeaders
FindFirstTeamLeadersArgs = FindManyTeamLeadersArgsFromTeamLeaders


    

class TeamLeadersWhereInput(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    memberId: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    member: 'MemberRelationFilter'
    team: 'TeamRelationFilter'

    # should be noted that AND and NOT should be Union['TeamLeadersWhereInputRecursive1', List['TeamLeadersWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TeamLeadersWhereInputRecursive1']
    OR: List['TeamLeadersWhereInputRecursive1']
    NOT: List['TeamLeadersWhereInputRecursive1']


class TeamLeadersWhereInputRecursive1(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    memberId: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    member: 'MemberRelationFilter'
    team: 'TeamRelationFilter'

    # should be noted that AND and NOT should be Union['TeamLeadersWhereInputRecursive2', List['TeamLeadersWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TeamLeadersWhereInputRecursive2']
    OR: List['TeamLeadersWhereInputRecursive2']
    NOT: List['TeamLeadersWhereInputRecursive2']


class TeamLeadersWhereInputRecursive2(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    memberId: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    member: 'MemberRelationFilter'
    team: 'TeamRelationFilter'

    # should be noted that AND and NOT should be Union['TeamLeadersWhereInputRecursive3', List['TeamLeadersWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TeamLeadersWhereInputRecursive3']
    OR: List['TeamLeadersWhereInputRecursive3']
    NOT: List['TeamLeadersWhereInputRecursive3']


class TeamLeadersWhereInputRecursive3(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    memberId: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    member: 'MemberRelationFilter'
    team: 'TeamRelationFilter'

    # should be noted that AND and NOT should be Union['TeamLeadersWhereInputRecursive4', List['TeamLeadersWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TeamLeadersWhereInputRecursive4']
    OR: List['TeamLeadersWhereInputRecursive4']
    NOT: List['TeamLeadersWhereInputRecursive4']


class TeamLeadersWhereInputRecursive4(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    memberId: Union[_str, 'types.StringFilter']
    teamId: Union[_str, 'types.StringFilter']
    member: 'MemberRelationFilter'
    team: 'TeamRelationFilter'



# aggregate TeamLeaders types


    

class TeamLeadersScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    memberId: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamLeadersScalarWhereWithAggregatesInputRecursive1']
    OR: List['TeamLeadersScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TeamLeadersScalarWhereWithAggregatesInputRecursive1']


class TeamLeadersScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    memberId: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamLeadersScalarWhereWithAggregatesInputRecursive2']
    OR: List['TeamLeadersScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TeamLeadersScalarWhereWithAggregatesInputRecursive2']


class TeamLeadersScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    memberId: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamLeadersScalarWhereWithAggregatesInputRecursive3']
    OR: List['TeamLeadersScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TeamLeadersScalarWhereWithAggregatesInputRecursive3']


class TeamLeadersScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    memberId: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TeamLeadersScalarWhereWithAggregatesInputRecursive4']
    OR: List['TeamLeadersScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TeamLeadersScalarWhereWithAggregatesInputRecursive4']


class TeamLeadersScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """TeamLeaders arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    memberId: Union[_str, 'types.StringWithAggregatesFilter']
    teamId: Union[_str, 'types.StringWithAggregatesFilter']



class TeamLeadersGroupByOutput(TypedDict, total=False):
    id: _str
    memberId: _str
    teamId: _str
    _sum: 'TeamLeadersSumAggregateOutput'
    _avg: 'TeamLeadersAvgAggregateOutput'
    _min: 'TeamLeadersMinAggregateOutput'
    _max: 'TeamLeadersMaxAggregateOutput'
    _count: 'TeamLeadersCountAggregateOutput'


class TeamLeadersAvgAggregateOutput(TypedDict, total=False):
    """TeamLeaders output for aggregating averages"""


class TeamLeadersSumAggregateOutput(TypedDict, total=False):
    """TeamLeaders output for aggregating sums"""


class TeamLeadersScalarAggregateOutput(TypedDict, total=False):
    """TeamLeaders output including scalar fields"""
    id: _str
    memberId: _str
    teamId: _str


TeamLeadersMinAggregateOutput = TeamLeadersScalarAggregateOutput
TeamLeadersMaxAggregateOutput = TeamLeadersScalarAggregateOutput


class TeamLeadersMaxAggregateInput(TypedDict, total=False):
    """TeamLeaders input for aggregating by max"""
    id: bool
    memberId: bool
    teamId: bool


class TeamLeadersMinAggregateInput(TypedDict, total=False):
    """TeamLeaders input for aggregating by min"""
    id: bool
    memberId: bool
    teamId: bool


class TeamLeadersNumberAggregateInput(TypedDict, total=False):
    """TeamLeaders input for aggregating numbers"""


TeamLeadersAvgAggregateInput = TeamLeadersNumberAggregateInput
TeamLeadersSumAggregateInput = TeamLeadersNumberAggregateInput


TeamLeadersCountAggregateInput = TypedDict(
    'TeamLeadersCountAggregateInput',
    {
        'id': bool,
        'memberId': bool,
        'teamId': bool,
        '_all': bool,
    },
    total=False,
)

TeamLeadersCountAggregateOutput = TypedDict(
    'TeamLeadersCountAggregateOutput',
    {
        'id': int,
        'memberId': int,
        'teamId': int,
        '_all': int,
    },
    total=False,
)


TeamLeadersKeys = Literal[
    'id',
    'memberId',
    'teamId',
    'member',
    'team',
]
TeamLeadersScalarFieldKeys = Literal[
    'id',
    'memberId',
    'teamId',
]
TeamLeadersScalarFieldKeysT = TypeVar('TeamLeadersScalarFieldKeysT', bound=TeamLeadersScalarFieldKeys)

TeamLeadersRelationalFieldKeys = Literal[
        'member',
        'team',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields